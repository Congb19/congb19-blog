---
title: 大华恒生一面回顾
date: 2021-03-14 17:32:59
tags:
id: 292
---

[大华一面、恒生一面](../posts/290/)中，
答得不好的点，做一下回顾记录。

---

### 1. Event Loop

<!-- more -->

JS 运行在浏览器中是单线程的，但是浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。浏览器中很多异步行为都是由浏览器新开一个线程去完成，一个浏览器至少实现三个常驻线程：JS 引擎线程、GUI 渲染线程、事件触发线程。

- JS 引擎
  JavaScript 引擎是一个专门处理 JavaScript 脚本的虚拟机，一般会附带在网页浏览器之中，比如最出名的就是 Chrome 浏览器的 V8 引擎，如下图所示，JS 引擎主要有两个组件构成：

  - 堆-内存分配发生的地方
  - 栈-函数调用时会形一个个栈帧（frame）

- 执行栈
  JS 引擎中，每一个**函数**执行的时候，都会生成新的 execution context（执行上下文），执行上下文会包含一些当前函数的参数、局部变量之类的信息，它会被推入栈中，**running execution context（正在执行的上下文）始终处于栈的顶部**。当函数**执行完后，它的执行上下文会从栈弹出**。

- Event Loop
  指的就是一个程序结构，用于等待和发送消息和事件。（a programming construct that waits for and dispatches events or messages in a program.）简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为"主线程"；另一个负责主线程与其他进程（主要是各种 I/O 操作）的通信，被称为"Event Loop 线程"（可以译为"消息线程"）。

事件循环的过程可以简单描述为：

1. 函数入栈，当栈中执行到异步任务的时候，就将他丢给 WebAPIs,接着执行同步任务,直到栈为空；
2. 在此期间 WebAPIs 完成这个事件，把回调函数放入 CallbackQueue 中等待；
3. 当执行栈为空时，Event Loop 把 Callback Queue 中的一个任务放入栈中，回到第 1 步。

注意点：

1. Event Loop 是由 javascript 宿主环境（像浏览器）来实现的;
2. WebAPIs 是由 C++实现的浏览器创建的线程，处理诸如 DOM 事件、http 请求、定时器等异步事件;
3. JavaScript 的并发模型基于"事件循环";
4. Callback Queue(Event Queue 或者 Message Queue) 任务队列，存放异步任务的回调函数

例子：

```JavaScript
Promise.resolve().then(function promise1() {
  console.log('promise1');
})
setTimeout(function setTimeout1() {
  console.log('setTimeout1')
  Promise.resolve().then(function promise2() {
    console.log('promise2');
  })
}, 0)

setTimeout(function setTimeout2() {
  console.log('setTimeout2')
}, 0)
```

解析：
1. 执行loop1：**微任务**：无；**宏任务**：执行script（整体），promise1()加入loop2的微任务，setTimeout1()加入loop2的宏任务，setTimeout2加入loop2的宏任务；
2. 执行loop2：**微任务**：执行promise1()，输出'promise1'；**宏任务**：执行setTimeout1()，输出'setTimeout1'，promise2()加入loop3的微任务，执行setTimeout2()，输出'setTimeout2'；
3. 执行loop3：**微任务**：执行promise2()，输出'promise2'；**宏任务**：无。
输出为：
promise1
setTimeout1
setTimeout2
promise2

> 回答：在代码执行的时候，通过将不同函数的执行上下文压入执行栈中，来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，JS 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到下一次事件循环的对应队列中 去等待执行。
> 任务可以分为宏任务和微任务，**当当前执行栈中的事件执行完毕后，js 引擎会进入下一轮事件循环，先判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后，再去执行宏任务队列中的任务**。

### 2. vue-watch、computed

1. computed 是**计算一个新的属性，并将该属性挂载到 Vue 实例上**，而 watch 是**监听已经存在且已挂载到 Vue 实例上的数据**，所以用 watch 同样可以监听 computed 计算属性的变化。
2. computed 本质是一个惰性求值的观察者，具有缓存性，**只有当依赖变化后，第一次访问 computed 属性，才会计算新的值**。而 **watch 则是当数据发生变化便会调用执行函数**。
3. 从使用场景上说，**computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据**。

### 3. vue3.0、vite 介绍



### 4. 项目亮点和难点的思路
